#pragma config(Sensor, dgtl1,  rightencoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftencoder,    sensorQuadEncoder)
#pragma config(Motor,  port1,           leftmotor,     tmotorVex393_HBridge, openLoop, reversed, driveLeft)
#pragma config(Motor,  port6,            ,             tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,            ,             tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          rightmotor,    tmotorVex393_HBridge, openLoop, driveRight)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

task main()
{
	
int AdjN;
int AdjS;
int Rt90R;
int Rt90L;
int Lt90R;
int Lt90L;
int TurnSP;
int TurnSN;

AdjN = 127;
AdjS = 63;
Rt90R = 415;
Rt90L = -415;
Lt90R = -420;
Lt90L = 420;
TurnSP = 96;
TurnSN = -96;

//Straightening code
SensorValue[rightencoder]=0;
SensorValue[leftencoder]=0;

while(SensorValue[leftencoder]<1200 && SensorValue[rightencoder]<1200) //Sets encoder value for going forward.
	{
		if (SensorValue[leftencoder] < SensorValue[rightencoder]) // Calculates if the right encoder is at a higher count than the left.
		{
			motor[rightmotor]=AdjS; // Lowers right motors power level.
			motor[leftmotor]=AdjN; // Raises left motors power level.
		}
		else if (SensorValue[leftencoder] > SensorValue[rightencoder]) // Calculates if the right encoder is at a lower count than the left.
		{
			motor[rightmotor]=AdjN; // Raises right motors power level.
			motor[leftmotor]=AdjS; // Lowers left motors power level.
		}
		else (SensorValue[leftencoder] == SensorValue[rightencoder]); // Calculates if the right encoder is at an equal count to the left.
		{
			motor[rightmotor]=AdjN; // Equalizes motor speed.
			motor[leftmotor]=AdjN; // Equalizes motor speed.
		}
	}

//Right point turn (90 degree)
SensorValue[rightencoder]=Rt90R; // Set's encoder value for turn.
SensorValue[leftencoder]=Rt90L; // Set's encoder value for turn.

while (SensorValue[rightencoder]>Rt90R && SensorValue[leftencoder]<Rt90L) //Sets encoder value for turn
  {
	motor[rightmotor]=TurnSN; // Motor is set to run until it is greater than -423.
	motor[leftmotor]=TurnSP;// Motor is set to run until it is greater than 423.
  }

//Straightening code
SensorValue[rightencoder]=0;
SensorValue[leftencoder]=0;

while(SensorValue[leftencoder]<1200 && SensorValue[rightencoder]<1200) //Sets encoder value for going forward.
	{
		if (SensorValue[leftencoder] < SensorValue[rightencoder]) // Calculates if the right encoder is at a higher count than the left.
		{
			motor[rightmotor]=AdjS; // Lowers right motors power level.
			motor[leftmotor]=AdjN; // Raises left motors power level.
		}
		else if (SensorValue[leftencoder] > SensorValue[rightencoder]) // Calculates if the right encoder is at a lower count than the left.
		{
			motor[rightmotor]=AdjN; // Raises right motors power level.
			motor[leftmotor]=AdjS; // Lowers left motors power level.
		}
		else (SensorValue[leftencoder] == SensorValue[rightencoder]); // Calculates if the right encoder is at an equal count to the left.
		{
			motor[rightmotor]=AdjN; // Equalizes motor speed.
			motor[leftmotor]=AdjN; // Equalizes motor speed.
		}
	}

//Right point turn (90 degree)
SensorValue[rightencoder]=Rt90R; // Set's encoder value for turn.
SensorValue[leftencoder]=Rt90L; // Set's encoder value for turn.

while (SensorValue[rightencoder]>Rt90R && SensorValue[leftencoder]<Rt90L) //Sets encoder value for turn
  {
	motor[rightmotor]=TurnSN; // Motor is set to run until it is greater than -423.
	motor[leftmotor]=TurnSP;// Motor is set to run until it is greater than 423.
  }

//Straightening code
SensorValue[rightencoder]=0;
SensorValue[leftencoder]=0;

while(SensorValue[leftencoder]<1200 && SensorValue[rightencoder]<1200) //Sets encoder value for going forward.
	{
		if (SensorValue[leftencoder] < SensorValue[rightencoder]) // Calculates if the right encoder is at a higher count than the left.
		{
			motor[rightmotor]=AdjS; // Lowers right motors power level.
			motor[leftmotor]=AdjN; // Raises left motors power level.
		}
		else if (SensorValue[leftencoder] > SensorValue[rightencoder]) // Calculates if the right encoder is at a lower count than the left.
		{
			motor[rightmotor]=AdjN; // Raises right motors power level.
			motor[leftmotor]=AdjS; // Lowers left motors power level.
		}
		else (SensorValue[leftencoder] == SensorValue[rightencoder]); // Calculates if the right encoder is at an equal count to the left.
		{
			motor[rightmotor]=AdjN; // Equalizes motor speed.
			motor[leftmotor]=AdjN; // Equalizes motor speed.
		}
	}

//Left point turn (90 degree)
SensorValue[rightencoder]=-Lt90R; //Set's encoder value for turn.
SensorValue[leftencoder]=Lt90L; // Set's encoder value for turn.

while (SensorValue[rightencoder]<Lt90R && SensorValue[leftencoder]>-Lt90L)//Sets encoder value for turn
  {
	motor[rightmotor]=TurnSP; // Motor is set to run until it is greater than 800.
	motor[leftmotor]=TurnSN;// Motor is set to run until it is greater than -800.
  }

//Straightening code
SensorValue[rightencoder]=0;
SensorValue[leftencoder]=0;

while(SensorValue[leftencoder]<1200 && SensorValue[rightencoder]<1200) //Sets encoder value for going forward.
	{
		if (SensorValue[leftencoder] < SensorValue[rightencoder]) // Calculates if the right encoder is at a higher count than the left.
		{
			motor[rightmotor]=AdjS; // Lowers right motors power level.
			motor[leftmotor]=AdjN; // Raises left motors power level.
		}
		else if (SensorValue[leftencoder] > SensorValue[rightencoder]) // Calculates if the right encoder is at a lower count than the left.
		{
			motor[rightmotor]=AdjN; // Raises right motors power level.
			motor[leftmotor]=AdjS; // Lowers left motors power level.
		}
		else (SensorValue[leftencoder] == SensorValue[rightencoder]); // Calculates if the right encoder is at an equal count to the left.
		{
			motor[rightmotor]=AdjN; // Equalizes motor speed.
			motor[leftmotor]=AdjN; // Equalizes motor speed.
		}
	}
	
//Left point turn (90 degree)
SensorValue[rightencoder]=-Lt90R; //Set's encoder value for turn.
SensorValue[leftencoder]=Lt90L; // Set's encoder value for turn.

while (SensorValue[rightencoder]<Lt90R && SensorValue[leftencoder]>-Lt90L)//Sets encoder value for turn
  {
	motor[rightmotor]=TurnSP; // Motor is set to run until it is greater than 800.
	motor[leftmotor]=TurnSN;// Motor is set to run until it is greater than -800.
  }

//Straightening code
SensorValue[rightencoder]=0;
SensorValue[leftencoder]=0;

while(SensorValue[leftencoder]<1200 && SensorValue[rightencoder]<1200) //Sets encoder value for going forward.
	{
		if (SensorValue[leftencoder] < SensorValue[rightencoder]) // Calculates if the right encoder is at a higher count than the left.
		{
			motor[rightmotor]=AdjS; // Lowers right motors power level.
			motor[leftmotor]=AdjN; // Raises left motors power level.
		}
		else if (SensorValue[leftencoder] > SensorValue[rightencoder]) // Calculates if the right encoder is at a lower count than the left.
		{
			motor[rightmotor]=AdjN; // Raises right motors power level.
			motor[leftmotor]=AdjS; // Lowers left motors power level.
		}
		else (SensorValue[leftencoder] == SensorValue[rightencoder]); // Calculates if the right encoder is at an equal count to the left.
		{
			motor[rightmotor]=AdjN; // Equalizes motor speed.
			motor[leftmotor]=AdjN; // Equalizes motor speed.
		}
	}

//Left point turn (90 degree)
SensorValue[rightencoder]=-Lt90R; //Set's encoder value for turn.
SensorValue[leftencoder]=Lt90L; // Set's encoder value for turn.

while (SensorValue[rightencoder]<Lt90R && SensorValue[leftencoder]>-Lt90L)//Sets encoder value for turn
  {
	motor[rightmotor]=TurnSP; // Motor is set to run until it is greater than 800.
	motor[leftmotor]=TurnSN;// Motor is set to run until it is greater than -800.
  }
  
//Straightening code
SensorValue[rightencoder]=0;
SensorValue[leftencoder]=0;

while(SensorValue[leftencoder]<1200 && SensorValue[rightencoder]<1200) //Sets encoder value for going forward.
	{
		if (SensorValue[leftencoder] < SensorValue[rightencoder]) // Calculates if the right encoder is at a higher count than the left.
		{
			motor[rightmotor]=AdjS; // Lowers right motors power level.
			motor[leftmotor]=AdjN; // Raises left motors power level.
		}
		else if (SensorValue[leftencoder] > SensorValue[rightencoder]) // Calculates if the right encoder is at a lower count than the left.
		{
			motor[rightmotor]=AdjN; // Raises right motors power level.
			motor[leftmotor]=AdjS; // Lowers left motors power level.
		}
		else (SensorValue[leftencoder] == SensorValue[rightencoder]); // Calculates if the right encoder is at an equal count to the left.
		{
			motor[rightmotor]=AdjN; // Equalizes motor speed.
			motor[leftmotor]=AdjN; // Equalizes motor speed.
		}
	}

//Right point turn (90 degree)
SensorValue[rightencoder]=Rt90R; // Set's encoder value for turn.
SensorValue[leftencoder]=Rt90L; // Set's encoder value for turn.

while (SensorValue[rightencoder]>Rt90R && SensorValue[leftencoder]<Rt90L) //Sets encoder value for turn
  {
	motor[rightmotor]=TurnSN; // Motor is set to run until it is greater than -423.
	motor[leftmotor]=TurnSP;// Motor is set to run until it is greater than 423.
  }

//Straightening code
SensorValue[rightencoder]=0;
SensorValue[leftencoder]=0;

while(SensorValue[leftencoder]<1200 && SensorValue[rightencoder]<1200) //Sets encoder value for going forward.
	{
		if (SensorValue[leftencoder] < SensorValue[rightencoder]) // Calculates if the right encoder is at a higher count than the left.
		{
			motor[rightmotor]=AdjS; // Lowers right motors power level.
			motor[leftmotor]=AdjN; // Raises left motors power level.
		}
		else if (SensorValue[leftencoder] > SensorValue[rightencoder]) // Calculates if the right encoder is at a lower count than the left.
		{
			motor[rightmotor]=AdjN; // Raises right motors power level.
			motor[leftmotor]=AdjS; // Lowers left motors power level.
		}
		else (SensorValue[leftencoder] == SensorValue[rightencoder]); // Calculates if the right encoder is at an equal count to the left.
		{
			motor[rightmotor]=AdjN; // Equalizes motor speed.
			motor[leftmotor]=AdjN; // Equalizes motor speed.
		}
	}

}
